数据结构是一门讨论对于非数值计算的问题如何存储数据、采用适合的方式表示结构（关系）、实现操作（各种算法）的课程
数据的基本单位是数据元素，数据的最小单位是数据项，数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
计算机算法必须具备输入、输出和可行性，确定性，有穷性五个特性。
抽象数据类型中的基本操作定义是抽象的，与具体实现无关。
在数据结构中，与所使用的计算机无关的数据结构是逻辑结构。
算法的时间复杂度取决于问题的规模，待处理数据的初态
计算机算法指的是解决问题的有限运算序列

顺序表：顺序存储，随机存取
访问元素：O(1)
插入元素（末尾）：平均O(1)（如果需要考虑数组扩容，则最坏情况下为O(n)）
删除元素（末尾）：平均O(1)（如果需要考虑数组缩容，则最坏情况下为O(n)）
插入元素（中间或开头）：O(n)
删除元素（中间或开头）：O(n)
删除一个元素平均需要移动元素的个数是(n-1)/2
插入一个元素平均需要移动元素的个数是n/2

1.顺序表操作集
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 5
#define ERROR -1
typedef enum {false, true} bool;
typedef int ElementType;
typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List MakeEmpty(){
    List L;
    L=(struct LNode*)malloc(sizeof(struct LNode));
    L->Last=-1;
    return L;
}
Position Find( List L, ElementType X ){
    for(int i=0;i<=L->Last;i++){
        if(L->Data[i]==X){
            return i;
        }
    }
    return ERROR;
}
bool Insert( List L, ElementType X, Position P ){
    if(L->Last==MAXSIZE-1){
        printf("List is full.\n");
        return false;
    }
    if(P<0||P>L->Last+1){
        printf("Position error.\n");
        return false;
    }
    for(int i=L->Last;i>=P;i--){
        L->Data[i+1]=L->Data[i];
    }
    L->Data[P]=X;
    L->Last++;
    return true;
}
bool Delete( List L, Position P ){
    if(P<0||P>L->Last){
        printf("Position error.\n");
        return false;
    }
    for(int i=P;i<L->Last;i++){
        L->Data[i]=L->Data[i+1];
    }
    L->Last--;
    return true;
}

int main()
{
    List L;
    ElementType X;
    Position P;
    int N;

    L = MakeEmpty();
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &X);
        if ( Insert(L, X, 0)==false )
            printf(" Insertion Error: %d is not in.\n", X);
    }
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &X);
        P = Find(L, X);
        if ( P == ERROR )
            printf("Finding Error: %d is not in.\n", X);
        else
            printf("%d is at position %d.\n", X, P);
    }
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &P);
        if ( Delete(L, P)==false )
            printf(" Deletion Error.\n");
        if ( Insert(L, 0, P)==false )
            printf(" Insertion Error: 0 is not in.\n");
    }
    return 0;
}
2.有序表插入数据
#include <iostream>
#define MaxSize 50
using namespace std;
typedef int ElemType; 
typedef struct {    
     ElemType data[MaxSize];        //存放顺序表元素
       int length ;                    //存放顺序表的长度
}List;    
typedef List *SqList;
void CreateSqList(SqList &L,int n){
    L=new List;
    L->length=n;
    for(int i=0;i<n;i++){
        cin>>L->data[i];
    }
}
void InsertSq(SqList &L,int x) {
    int i,j=0;
    for(i=0;i<L->length;i++){
        if(L->data[i]>=x){
            break;
        }
    }
    for(j=L->length;j>=i;j--){
        L->data[j+1]=L->data[j];
    }
    L->data[i]=x;
    L->length++;
}
void DispSqList(SqList L){
    if(L->length==0){
        cout<<"error"<<endl;
    }
    else{
        cout<<L->data[0];
        for(int i=1;i<L->length;i++){
            cout<<" "<<L->data[i];
        }
        cout<<endl;
    }
}
void DestroySqList(SqList &L);//销毁线性表
int main()
{
     int n;
    SqList L;
    cin>>n; 
    CreateSqList(L,n)  ;
     if(n>0)
    {
     cin>>n;
     InsertSq(L,n) ;
    }
     DispSqList(L);  
     DestroySqList(L);//细节不表
}
/* 请在这里填写答案 */
3.实现顺序表的就地逆置
#include <stdio.h>
#include <stdlib.h>

typedef int DataType; //数据元素类型定义为整型
struct List
{
    int Max;        //顺序表的最大容量
    int n;          //顺序表长度
    DataType *elem; //顺序表元素起始位置
};
typedef struct List *SeqList; //顺序表类型定义

SeqList SetNullList_Seq(int m) //创建空顺序表
{
    //申请结构体List空间
    SeqList slist = (SeqList)malloc(sizeof(struct List));
    if (slist != NULL)
    {
        slist->elem = (DataType *)malloc(sizeof(DataType) * m);
        //申请顺序表空间，大小为m个DataType空间
        if (slist->elem)
        {
            slist->Max = m; //顺序表的最大值
            slist->n = 0;   //顺序表长度赋值为0
            return (slist);
        }
        else
            free(slist);
    }
    printf("out of space!!\n");
    return NULL;
}

void print(SeqList slist) //输出顺序表
{
    int i;
    for (i = 0; i < slist->n; i++)
    {
        printf("%d ", slist->elem[i]);
    }
    printf("\n");
    return;
}

void reverse(SeqList slist){
    for(int i=0;i<slist->n/2;i++){
        int temp=slist->elem[i];
        slist->elem[i]=slist->elem[slist->n-i-1];
        slist->elem[slist->n-i-1]=temp;
    }
}

int main(void)
{
    SeqList test = SetNullList_Seq(5); //初始化一个最大长度为5的顺序表;
    
    for (int i = 0; i < 5; ++i) test->elem[i] = i + 1, ++test->n; //5个元素分别赋值为1到5, 增加元素个数;
    reverse(test);
    printf("反转表后的元素如下:\n");
    print(test);
    free(test->elem); //释放堆内存;

    return 0;
}

链表：随机存储，顺序存取
在单链表中，增加头结点可以使空表和非空表的处理统一，根本目的是为了方便运算的实现
将长度分别为m,n的两个单链表合并为一个单链表的时间复杂度为O(m*n)，如果两个表都是有序表则时间复杂度为(m+n).
访问元素：O(n)（需要遍历链表）
插入元素（末尾）：O(n)（在单向链表中需要遍历到末尾；在双向链表中可以直接在尾部插入）
删除元素（末尾）：O(n)（在单向链表中需要遍历到末尾并调整前一个节点的指针）
插入元素（中间或开头）：O(1)（只需调整相邻节点的指针）
删除元素（中间或开头）：O(1)（只需调整相邻节点的指针）
4.链式表操作集
#include <stdio.h>
#include <stdlib.h>

#define ERROR NULL
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode {
    ElementType Data;
    PtrToLNode Next;
};
typedef PtrToLNode Position;
typedef PtrToLNode List;

Position Find( List L, ElementType X )
{
    while(L!=NULL)
    {
        if(L->Data==X)
            return L;
        else
            L=L->Next;
    }
    return ERROR;
}
List Insert( List L, ElementType X, Position P )
{
    List h=L;
    List p=(List)malloc(sizeof(List));
    p->Data=X;
    p->Next=NULL;
    if(L==P)
    {
        p->Next=L;
        return p;
    }
    while(L)
    {
        if(P==L->Next)
        {
            p->Next=L->Next;
            L->Next=p;
            return h;
        }
        L=L->Next;
    }
    printf("Wrong Position for Insertion\n");
    return ERROR;
}
List Delete( List L, Position P )
{
    if(L==P){
        L=L->Next;
        return L; 
    }
    List h = L;
    while(L){
        if(L->Next==P){
            L->Next=P->Next;
            return h;
        }
        L=L->Next;
    }
    printf("Wrong Position for Deletion\n");
    return ERROR;
}


int main()
{
    List L;
    ElementType X;
    Position P, tmp;
    int N;

    L = NULL;
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &X);
        L = Insert(L, X, L);
        if ( L==ERROR ) printf("Wrong Answer\n");
    }
    scanf("%d", &N);
    while ( N-- ) {
        scanf("%d", &X);
        P = Find(L, X);
        if ( P == ERROR )
            printf("Finding Error: %d is not in.\n", X);
        else {
            L = Delete(L, P);
            printf("%d is found and deleted.\n", X);
            if ( L==ERROR )
                printf("Wrong Answer or Empty List.\n");
        }
    }
    L = Insert(L, X, NULL);
    if ( L==ERROR ) printf("Wrong Answer\n");
    else
        printf("%d is inserted as the last element.\n", X);
    P = (Position)malloc(sizeof(struct LNode));
    tmp = Insert(L, X, P);
    if ( tmp!=ERROR ) printf("Wrong Answer\n");
    tmp = Delete(L, P);
    if ( tmp!=ERROR ) printf("Wrong Answer\n");
    for ( P=L; P; P = P->Next ) printf("%d ", P->Data);
    return 0;
}

/* 你的代码将被嵌在这里 */
